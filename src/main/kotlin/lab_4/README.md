# Отношения между типами
В этой лабе используются *наследование*, *абстрактные классы*, *интерфейсы* и уже изученные оюычные классы.   
***Задача:*** написать код для игр "Балда" и "Крестики-нолики" с использованием разных типов.

## Наследование
***Наследование*** позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. В отношении наследования выделяются два ключевых компонента. Прежде всего это **базовый класс** (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. И **производный класс** (класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее.      

Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию `open`. По умолчанию без этой аннотации класс не может быть унаследован.      
Общий вид:    
```Kotlin
open class базовый_класс
class производный_класс: базовый_класс
```
> Замечание: если классу нужно передавать аргументы, то при наследовании их необходимо передать!

###### Ожидается обновление... // добавить код + диаграму, "super" - ?...

## Абстрактные классы и методы
***Абстрактные классы*** - это классы, определенные с модификатором **abstract**.       
***Абстрактный класс*** - это класс, представляющий из себя “заготовку” для целого семейства классов, который описывает для них общий шаблон поведения. Отличительной особенностью абстрактных классов является то, что мы **не** можем создать объект подобного класса.

Он представляет собой характеристики, которые относятся к отпередленной группе, но не имеют четкой формы. Например, квадрат и круг - это фигуры, но фигуры так таковой не существует, у них из общего есть периметр и площадь, которые являются абстрактными. То есть периметр и площадь имеют все фигуры вне зависимости какой они формы.
```Kotlin
// абстрактный класс фигуры
abstract class Figure {
    // абстрактный метод для получения периметра
    abstract fun perimeter(): Float
 
    // абстрактный метод для получения площади
    abstract fun area(): Float
}
// производный класс прямоугольника
class Rectangle(val width: Float, val height: Float) : Figure()
{
    // переопределение получения периметра
    override fun perimeter(): Float{
        return width * 2 + height * 2
    }
    // переопрелеление получения площади
    override fun area(): Float{
        return width * height
    }
}
```
Или, например, **абсолютно все** транспортные средства, будь то автобус, самолет или лодка, они все могут перемещаться. Это будет абстрактным методом, так как это свойственно всей группе вне зависимости от их типа.
```Kotlin
// абстрактный класс транспорта
abstract class Transport {
    // абстрактные методы перемещения
    abstract fun move() // движение
    abstract fun stop() // остановка
}
// производный класс транспорта
class Car() : Transport()
{
    // переопределение для движения
    override fun move(){
        print("Ехать!\n")
    }
    // переопрелеление для остановки
    override fun stop(){
        print("Тормозить!\n")
    }
}
```
Абстрактные классы могут иметь конструктор, а так же они могут использоваться для наследования.  
### Наследование

Все свойства и методы, отмеченные словом **abstract**, нужно переопределить с помощью `override`. Если они были опредленны по-умолчанию, то это можно не делать.



## Интерфейсы
***Интерфейсы*** представляют контракт, который должен реализовать класс. Интерфейсы могут содержать объявления свойств и функций, а также их реализацию по умолчанию.

***Интерфейс*** - это совокупность методов и правил, которые определяют ***поведение*** класса или ***общее поведение*** для группы независимых друг от друга классов. Интерфейсы похожи на абстрактные классы тем, что нельзя создать их экземпляры и они могут определять абстрактные или конкретные функции и свойства. Отличие в том, что интерфейсу не важна связь “родитель-наследник”, он задаёт лишь правила поведения.


###### Ожидается обновление... 

Для лучшего ознакомления с темой рекомендую посетить сайты [metanit.com](https://metanit.com/kotlin/tutorial/), [bimlibik](https://bimlibik.github.io/posts/kotlin-abstract-classes-and-interfaces/)
