# Вопросы к экзамену

## Содержание
1. [Тестирование](#Тестирование)   
2. [Отладка](#Отладка)    
3. Переменные и константы    
4. Сложные типы данных   
5. Управляющие конструкции   
6. Функции   
7. Свойства объектов   
8. Функции объектов    
9. Сравнение объектов    
10. Копирование объектов    
11. Понятие класса    
12. Первичный конструктор   
13. Вторичный конструктор   
14. Свойства объекта-компаньона   
15. Функции объекта-компаньона    
16. Синглтон и перечисления   
17. Дата классы
18. Композиция
19. Наследование
20. Реализация
21. Параметризация
22. Абстрактные классы
23. Множественное наследование
24. Полиморфизм
25. SOLID
26. Ковариантный параметр
27. Контравариантынй параметр
28. Обработка ошибок с помощью null-типов
29. Контроль ошибок с помощью кодов
30. Контроль ошибок с помощью исключений
31. Функциональная обработка ошибок
32. Рефлексия в программировании
33. Аннотации в программировании
34. Делегаты в Kotlin
35. Внедрение зависимостей
___

## Тестирование   
Для начала подключаем библиотеку тестирования `kotest`. Ниже приведен блок кода конфигурации build.gradle.kts.
```Kotlin
val kotestVersion = "5.4.1"
dependencies{
    testImplementation(
        "io.kotest:kotest-runner-junit5-jvm:$kotestVersion") }
tasks.withType<Test>().configureEach {
    useJUnitPlatform() }
```
Тесты записываются в класссе, наследующим StringSpec. StringSpec сводит синтаксис к абсолютному минимуму. 
Просто напишите строку, за которой следует лямбда-выражение с вашим тестовым кодом. Should be дословно переводится как "должно быть". 
Оно сравнивает эксперементальный результат с теоритическим. На этом построены все тесты.
```Kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
class GreatTest : StringSpec({
    "Простой тест" {
        great("Вася") shouldBe "Hello, Вася"
    }
})
```

## Отладка
>>>> Ожидание дополнений...
## Переменные и константы
**Пременные**   
Переменные могут быть двух видов: `val` и `var`. 
`val` происходит от слова value - неизменная величена, а `var` от variable - изменяемая величена.   

Синтаксис (общий вид):
```Kotlin
var/val название_переменной : тип_переменной = значение
```
*Примеры использования:*
```Kotlin
val a: Int = 1    // Общий вид
val b = 2         // Тип `Int` выводится компилятором
val c: Int        // Без инициализации тип обязателен
c = 3             // Отложенная инициализация
var x = 5         // Тип `Int` выводится компилятором
x += 1            // var можно изменять
```

**Константы**  
Константы имеют ключевое слово `const`.     
Пример:
```Kotlin
const val SIZE : Int = 15
```
> **Отличие `val` от `const`**    
Значение переменной `val` инициализируется во время выполнения, а `const` - во время компиляции. 

**Типы данных**     
*Целочисленные:*      
Byte (8 бит), Short (16), Int (32), Long (64).
```Kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1

val hex = 0x0F // 16-я cc
val bin = 0b00001011 // 2-я сс

val oneMillion = 1_000_000 // `_` для удобного чтения 
```
*Вещественные:*       
Float (32, IEEE754 single), Double (64, IEEE754 double).
```Kotlin
val pi = 3.14 // Double
// val one: Double = 1 // Error: type mismatch
val oneDouble = 1.0 // Double
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, фактическое значение равно 2.7182817

val scienceNotation = 123.5e10 
```
*Символьные:*       
Char (1 символ, поддерживает Unicode), String (Строка).     
```Kotlin
val aChar: Char = 'a'
println(aChar)
println('\n') // переход на другую строку
println('\uFF00') // ?

val s = "Hello, world!\n"
val text = """
    for (c in "foo")
        print(c)
"""
```
*Логические:*       
Boolean
```Kotlin
val myTrue: Boolean = true
val myFalse: Boolean = false
```
## Сложные типы данных

*Приметивы и объекты*     
```Kotlin
val number: Int = 1
val numberString: String = number.toString()
```
- Объекты имеют больше возможностей.
- Примитивы требуют меньше ресурсов.
- Kotlin автоматически выбирает представление встроенных типов.

*Массивы*       
```Kotlin
val x: IntArray = intArrayOf(1, 2, 3)     // массив примитивов
val y: Array< Int > = arrayOf(1, 2, 3)    // массив объектов
// Первый аргумент Array - размер массива
// второй - функция инициализации (i - индекс элемента)
val z: Array< Int > = Array(5, { i -> i*i }) 

x[0] = у.size          // 3
x[1] = z.last()        // 16
```

*Коллекции*     
```Kotlin
val x = ArrayList<Int>()
x.addAll(listOf(1, 2, 3))
x.add(5)
print(x)
``` 
```
[1, 2, 3, 5]
```
<!-- ```Kotlin
```  -->
*Структура данных*      
```Kotlin
class Good(val price: Float, val name: String)

val mail: Good = Good(10F, "mail")
val awl: Good = Good(20F, "awl")

val total = mail.price + awl.price
``` 

*Диапозоны*
```Kotlin
val r1: IntRange = 1..10
val r2: IntProgression = 10 downTo 1 step 2

println(5 in r1)
println(5 !in r2)
```
```
true
true
```

*Строки. Представления*     
```Kotlin
val i = 42
val s = "answer is $i"
val charArray: CharArray = s.toCharArray()
charArray[0] = charArray[0].uppercaseChar()
val newS: String = String(charArray)
print(newS)
```
```
Answer is 42
```

*Строки. Операции*      
```Kotlin
val s1 = "string one"
println(s1.uppercase())
println(s1.replace(" ", "_"))
println(s1.substring(1 .. 3))
println(s1.split(" "))
```
```
STRING ONE
string_one
tri
[string, one]
```

*Кортежи (tuples)*      
```Kotlin
val p: Pair<Int, String> = Pair(1,"")
val t: Triple<Int, String, Char> = 
        Triple(p.first, p.second, '1')
```

>>>> Ожидание дополнений...
## Управляющие конструкции
>>>> Ожидание дополнений...
## Функции
>>>> Ожидание дополнений...
## Свойства объектов
>>>> Ожидание дополнений...
## Функции объектов
>>>> Ожидание дополнений...
## Сравнение объектов
>>>> Ожидание дополнений...
## Копирование объектов 
>>>> Ожидание дополнений...
## Понятие класса    
>>>> Ожидание дополнений...
## Первичный конструктор
>>>> Ожидание дополнений...
## Вторичный конструктор 
>>>> Ожидание дополнений...
## Свойства объекта-компаньона
>>>> Ожидание дополнений...
## Функции объекта-компаньона
>>>> Ожидание дополнений...
## Синглтон и перечисления
>>>> Ожидание дополнений...
## Дата классы
>>>> Ожидание дополнений...
## Композиция
>>>> Ожидание дополнений...
## Наследование
>>>> Ожидание дополнений...
## Реализация
>>>> Ожидание дополнений...
## Параметризация
>>>> Ожидание дополнений...
## Абстрактные классы
>>>> Ожидание дополнений...
## Множественное наследование
>>>> Ожидание дополнений...
## Полиморфизм
>>>> Ожидание дополнений...
## SOLID
>>>> Ожидание дополнений...
## Ковариантный параметр
>>>> Ожидание дополнений...
## Контравариантынй параметр
>>>> Ожидание дополнений...
## Обработка ошибок с помощью null-типов
>>>> Ожидание дополнений...
## Контроль ошибок с помощью кодов
>>>> Ожидание дополнений...
## Контроль ошибок с помощью исключений
>>>> Ожидание дополнений...
## Функциональная обработка ошибок
>>>> Ожидание дополнений...
## Рефлексия в программировании
>>>> Ожидание дополнений...
## Аннотации в программировании
>>>> Ожидание дополнений...
## Делегаты в Kotlin
>>>> Ожидание дополнений...
## Внедрение зависимостей
>>>> Ожидание дополнений...
## Вывод
>>>> Пока нет...
