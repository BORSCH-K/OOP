# Вопросы к экзамену

## Содержание
1. [Тестирование](#Тестирование)   
2. [Отладка](#Отладка)    
3. [Переменные и константы](#Переменные-и-константы)    
4. [Сложные типы данных](#сложные-типы-данных)   
5. [Управляющие конструкции](#управляющие-конструкции)   
6. [Функции](#функции)
7. [Свойства объектов](#свойства-объектов)   
8. [Функции объектов](#функции-объектов)    
9. [Сравнение объектов](#сравнение-объектов)
10. [Копирование объектов](#копирование-объектов)    
11. [Понятие класса](#понятие-класса)    
12. [Первичный конструктор](#первичный-конструктор)   
13. [Вторичный конструктор](#вторичный-конструктор)   
14. [Свойства объекта-компаньона](#свойства-объекта-компаньона)   
15. [Функции объекта-компаньона](#функции-объекта-компаньона)    
16. [Синглтон и перечисления](#синглтон-и-перечисления)   
17. [Дата классы](#дата-классы)
18. [Композиция](#композиция)
19. [Наследование](#наследование)
20. [Реализация](#реализация)
21. [Параметризация](#параметризация)
22. [Абстрактные классы](#абстрактные-классы)
23. [Множественное наследование](#множественное-наследование)
24. [Полиморфизм](#полиморфизм)
25. [SOLID](#solid)
26. [Ковариантный параметр](#ковариантный-параметр)
27. [Контравариантынй параметр](#контравариантынй-параметр)
28. [Обработка ошибок с помощью null-типов](#обработка-ошибок-с-помощью-null-типов)
29. [Контроль ошибок с помощью кодов](#контроль-ошибок-с-помощью-кодов)
30. [Контроль ошибок с помощью исключений](#контроль-ошибок-с-помощью-исключений)
31. [Функциональная обработка ошибок](#функциональная-обработка-ошибок)
32. [Рефлексия в программировании](#рефлексия-в-программировании)
33. [Аннотации в программировании](#аннотации-в-программировании)
34. [Делегаты в Kotlin](#делегаты-в-kotlin)
35. [Внедрение зависимостей](#внедрение-зависимостей)
___

## Тестирование
Для начала подключаем библиотеку тестирования `kotest`. Ниже приведен блок кода конфигурации build.gradle.kts.
```Kotlin
val kotestVersion = "5.4.1"
dependencies{
    testImplementation(
        "io.kotest:kotest-runner-junit5-jvm:$kotestVersion") }
tasks.withType<Test>().configureEach {
    useJUnitPlatform() }
```
Тесты записываются в класссе, наследующим StringSpec. StringSpec сводит синтаксис к абсолютному минимуму. 
Просто напишите строку, за которой следует лямбда-выражение с вашим тестовым кодом. Should be дословно переводится как "должно быть". 
Оно сравнивает эксперементальный результат с теоритическим. На этом построены все тесты.
```Kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
class GreatTest : StringSpec({
    "Простой тест" {
        great("Вася") shouldBe "Hello, Вася"
    }
})
```

## Отладка
>>>> Ожидание дополнений...
## Переменные и константы
**Пременные**   
Переменные могут быть двух видов: `val` и `var`. 
`val` происходит от слова value - неизменная величена, а `var` от variable - изменяемая величена.   

Синтаксис (общий вид):
```Kotlin
var/val название_переменной : тип_переменной = значение
```
*Примеры использования:*
```Kotlin
val a: Int = 1    // Общий вид
val b = 2         // Тип `Int` выводится компилятором
val c: Int        // Без инициализации тип обязателен
c = 3             // Отложенная инициализация
var x = 5         // Тип `Int` выводится компилятором
x += 1            // var можно изменять
```

**Константы**  
Константы имеют ключевое слово `const`.     
Пример:
```Kotlin
const val SIZE : Int = 15
```
> **Отличие `val` от `const`**    
Значение переменной `val` инициализируется во время выполнения, а `const` - во время компиляции. 

**Типы данных**     
*Целочисленные:*      
Byte (8 бит), Short (16), Int (32), Long (64).
```Kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1

val hex = 0x0F // 16-я cc
val bin = 0b00001011 // 2-я сс

val oneMillion = 1_000_000 // `_` для удобного чтения 
```
*Вещественные:*       
Float (32, IEEE754 single), Double (64, IEEE754 double).
```Kotlin
val pi = 3.14 // Double
// val one: Double = 1 // Error: type mismatch
val oneDouble = 1.0 // Double
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, фактическое значение равно 2.7182817

val scienceNotation = 123.5e10 
```
*Символьные:*       
Char (1 символ, поддерживает Unicode), String (Строка).     
```Kotlin
val aChar: Char = 'a'
println(aChar)
println('\n') // переход на другую строку
println('\uFF00') // ?

val s = "Hello, world!\n"
val text = """
    for (c in "foo")
        print(c)
"""
```
*Логические:*       
Boolean
```Kotlin
val myTrue: Boolean = true
val myFalse: Boolean = false
```
## Сложные типы данных

*Приметивы и объекты*     
```Kotlin
val number: Int = 1
val numberString: String = number.toString()
```
- Объекты имеют больше возможностей.
- Примитивы требуют меньше ресурсов.
- Kotlin автоматически выбирает представление встроенных типов.

*Массивы*       
```Kotlin
val x: IntArray = intArrayOf(1, 2, 3)     // массив примитивов
val y: Array< Int > = arrayOf(1, 2, 3)    // массив объектов
// Первый аргумент Array - размер массива
// второй - функция инициализации (i - индекс элемента)
val z: Array< Int > = Array(5, { i -> i*i }) 

x[0] = у.size          // 3
x[1] = z.last()        // 16
```

*Коллекции*     
```Kotlin
val x = ArrayList<Int>()
x.addAll(listOf(1, 2, 3))
x.add(5)
print(x)
``` 
```
[1, 2, 3, 5]
```
*Структура данных*      
```Kotlin
class Good(val price: Float, val name: String)

val mail: Good = Good(10F, "mail")
val awl: Good = Good(20F, "awl")

val total = mail.price + awl.price
``` 

*Диапозоны*
```Kotlin
val r1: IntRange = 1..10
val r2: IntProgression = 10 downTo 1 step 2

println(5 in r1)
println(5 !in r2)
```
```
true
true
```

*Строки. Представления*     
```Kotlin
val i = 42
val s = "answer is $i"
val charArray: CharArray = s.toCharArray()
charArray[0] = charArray[0].uppercaseChar()
val newS: String = String(charArray)
print(newS)
```
```
Answer is 42
```

*Строки. Операции*      
```Kotlin
val s1 = "string one"
println(s1.uppercase())
println(s1.replace(" ", "_"))
println(s1.substring(1 .. 3))
println(s1.split(" "))
```
```
STRING ONE
string_one
tri
[string, one]
```

*Кортежи (tuples)*      
```Kotlin
val p: Pair<Int, String> = Pair(1,"")
val t: Triple<Int, String, Char> = 
        Triple(p.first, p.second, '1')
```
>>>> Ожидание дополнений...
## Управляющие конструкции
**Ветвление**
```Kotlin
if (a % 2 == 0)
    print("a is even\n")
else
    print("a is odd\n")

val min = if (a < b) a else b
```
- Условие имеет тип Boolean.
- Возвращает значение.

**Выбор**
```Kotlin
var result = when(a){
    in 0..6 -> "ночь"
    in 6..12 -> "утро"
    in 12..18 -> "день"
    in 18..24 -> "вечер"
    else -> "ошибка"
}
```
Структурная конструкция (нет break!)

**Цикл для перебора**
```Kotlin
for(i in 0..5){
    print(i)
}
```
```Kotlin
val a = arrayOf(1, 2, 3)
var s = 0
for(x in a){
    s += x
}
```
Применяется при заранее известном числе повторений.

**Цикл для итераций**
```Kotlin
var bits = 10
while (bits > 0) {
    val tmp = bits / 2
    print(bits - 2 * tmp)
    bits = tmp
}
```
```Kotlin
print("\nEnter Yes\n")
do {
    val x = readLine()
} while (x != "Yes")
```

**Прерывание циклов**     
Kotlin содержит операторы continue(завершить шаг цикла) и break (завершить цикл), но при правильном подходе к реализации алгоритмов они не нужны.

>>>> Ожидание дополнений...
## Функции
**Объявление и вызов**      
```Kotlin
fun greeting(name: String): String {
    return "Hello $name"
}

print(greeting("Sheldon"))
```
**Аргументы по-умолчанию**
```Kotlin
fun greeting(name: String,
            prefix: String = "Dr."): String {
    return "Hello $prefix $name\n"
}

print(greeting("Sheldon"))
print(greeting("Howard", "Mr"))
```
**Именованные аргументы**
```Kotlin
fun greeting(name: String,
            prefix: String = "Dr.",
            greeting: String = "Hello"): String {
    return "Hello $prefix $name\n"
}

print(greeting("Sheldon", greeting = "Hi"))
```
**Функции из одного выражения**
```Kotlin
fun greeting(name: String,
            prefix: String = "Dr.",
            greeting: String = "Hello") =
    "Hello $prefix $name\n"
```
**Лямбда-функции**
```Kotlin
val arr: Array< Int > = Array(10) { it }

val isEven: (Int) -> Boolean = { n: Int -> n.rem(2) == 0 }

val evenArr: Array< Boolean > = Array(10, isEven)

val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y}
```

>>>> Ожидание дополнений...
## Свойства объектов

Свойство объекта - это переменная. В Kotlin для ее определения могут пременяться различные манипуляции.

**Геттеры и сеттеры**   
Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной.   
Геттер *определяет* значение переменной по прописанному методу, а сеттер *меняет* ее по прописанному методу.
Геттер:
```Kotlin
val x: Int
    get(value){ 
        if (value < 0)
            return -1
        return value
    }
``` 
Сеттер: 
```Kotlin
val y: Int = 0
    set(value){ 
        if (value % 2 == 0)
            field = value
        else 
            field = value - 1
    }
```
*field* - автоматически генерируемое поле, которое непосредственно хранит значение свойства.  
*value* - параметр, через который передается устанавливаемое значение.

**Nullable type**   
*Nullable* типы - это типы, переменный которых могут хранить два состояния: null (отсутствие состояние) и значение (само состояние).    
Пример:
```Kotlin
val x: Int? // может хранить значение `Int` или null
val y: Char // хранит только значение
```
// добавить определения !!, ?., ?! и тд

**Умное преобразование**    
В разных ЯП встречается преобразование типов. Например, из целого в вещественное и наоборот.    
Такое преобразование возможно, но имеет ограничения, например, переменные должны быть не null-евыми, в этом случае можно к каждому типу дописывать `?`, но это лишь снизит эффективность.
Пример: 
```Kotlin
val y: Int? = x
val a: Int = if (y != null) { // проверяет, что у не null-тип
    y*12
    } else {
    0
    }
```
>>>> Ожидание дополнений...
## Функции объектов
**Создание функций**
Функции могут оформляться двумя видами:
```Kotlin
// `fun` - ключевое слово
fun название_функции (параметры){тело_функции}
fun тип_примимаемого_аргумента.название_функции (параметры){тело_функции} // в этом случае для обращения к принемаемому аргументу используется ключевое слово `this`
```
**Контекст**    
// добавить

>>>> Ожидание дополнений...
## Сравнение объектов
>>>> Ожидание дополнений...
## Копирование объектов 
>>>> Ожидание дополнений...
## Понятие класса    

Класс - это "набор" свойств и методов определенной группы.  Ключевое слово `class`.
Например, класс "Человек" имеет сдующие характеристики: пол, возраст, рост... Это описание класса. А объект этого класса будет "конкретный" человек, имеющий определенный пол, возраст, рост...
 ```Kotlin
class Person(val name: String){ // принимает аргумент
    var age: Int = 18 // свойства могут быть определены по-умолчанию
}
fun main(){
    val Alex: Person = Person("Alex") // создание объекта с использованием агрумента
    Alex.age = 20 // изменение свойства
}
```
>>>> Ожидание дополнений...
## Первичный конструктор
<!-- ```Kotlin
```  -->



>>>> Ожидание дополнений...
## Вторичный конструктор 
>>>> Ожидание дополнений...
## Свойства объекта-компаньона
>>>> Ожидание дополнений...
## Функции объекта-компаньона
>>>> Ожидание дополнений...
## Синглтон и перечисления
>>>> Ожидание дополнений...
## Дата классы
>>>> Ожидание дополнений...
## Композиция
>>>> Ожидание дополнений...
## Наследование
>>>> Ожидание дополнений...
## Реализация
>>>> Ожидание дополнений...
## Параметризация
>>>> Ожидание дополнений...
## Абстрактные классы
>>>> Ожидание дополнений...
## Множественное наследование
>>>> Ожидание дополнений...
## Полиморфизм
>>>> Ожидание дополнений...
## SOLID

- Single responsibility – единственная ответственность класса, инкапсуляция ресурсов.
- Open-closed – классы открыты для расширения, закрыты для модификации.
- Liskov substitution (подстановка Liskov) – вместо базовых типов можно подставлять наследников.
- Interface segregation – много специализированных интерфейсов лучше одного универсального.
- Dependency inversion – использовать зависимость на абстракциях.

>>>> Ожидание дополнений...
## Ковариантный параметр
>>>> Ожидание дополнений...
## Контравариантынй параметр
>>>> Ожидание дополнений...
## Обработка ошибок с помощью null-типов
>>>> Ожидание дополнений...
## Контроль ошибок с помощью кодов
>>>> Ожидание дополнений...
## Контроль ошибок с помощью исключений
>>>> Ожидание дополнений...
## Функциональная обработка ошибок
>>>> Ожидание дополнений...
## Рефлексия в программировании
>>>> Ожидание дополнений...
## Аннотации в программировании
>>>> Ожидание дополнений...
## Делегаты в Kotlin
>>>> Ожидание дополнений...
## Внедрение зависимостей
>>>> Ожидание дополнений...
## Вывод
>>>> Пока нет...
